// go-multikeypair/keypair_test.go

package multikeypair

import (
	"bytes"
	crypto_rand "crypto/rand"
	//"fmt"
	"testing"

	//auth "golang.org/x/crypto/nacl/auth"
	box "golang.org/x/crypto/nacl/box"
	sign "golang.org/x/crypto/nacl/sign"
)

// Ensure that mapping from code to name, and name to code, are proper
// inverses.
func TestCodes(t *testing.T) {
	// identity
	if Names[Codes[IDENTITY]] != IDENTITY {
		t.Fatal("expected name and code to match for identity")
	}
	// ed25519
	if Names[Codes[ED_25519]] != ED_25519 {
		t.Fatal("expected name and code to match for ed25519")
	}
}

// Encode and decode a keypair with string key material.
func TestEncodeFixed(t *testing.T) {
	private := []byte("Wn3Sf5Ke/3:PA:Tm{KCf59Wg6j%/g*#d")
	public := []byte("cv-sB6?r*RW8vP5TuMSv_wvw#dV4nUP!@y%u@pmK!P-S2gYVLve!PfdC#kew5Q7U")
	code := ED_25519
	name := Codes[ED_25519]

	mk, err := Encode(private, public, code)
	if err != nil {
		t.Error(err)
	}
	kp, err := Decode(mk)
	if err != nil {
		t.Error(err)
	}

	validate(t, kp, code, name, public[:], private[:])
}

// Encode and decode a key generated by nacl sign package.
func TestEncodeSign(t *testing.T) {
	public, private, err := sign.GenerateKey(crypto_rand.Reader)
	if err != nil {
		t.Fatal("can't generate key")
	}
	code := ED_25519
	name := Codes[ED_25519]

	mk, err := Encode(private[:], public[:], code)
	if err != nil {
		t.Error(err)
	}
	kp, err := Decode(mk)
	if err != nil {
		t.Error(err)
	}

	validate(t, kp, code, name, public[:], private[:])
}

// Encode and decode a key generated by nacl box package.
func TestEncodeBox(t *testing.T) {
	public, private, err := box.GenerateKey(crypto_rand.Reader)
	if err != nil {
		t.Fatal("can't generate key")
	}
	code := ED_25519
	name := Codes[ED_25519]
	mk, err := Encode(private[:], public[:], code)
	if err != nil {
		t.Error(err)
	}
	kp, err := Decode(mk)
	if err != nil {
		t.Error(err)
	}

	validate(t, kp, code, name, public[:], private[:])
}

// Check that the contents of decoded keypair match the values that were
// used to construct it.
func validate(
	t *testing.T,
	// A decoded keypair.
	kp Keypair,
	// The cipher code.
	code uint64,
	// The cipher name.
	name string,
	// Public key bytes.
	public []byte,
	// Private key bytes.
	private []byte,
) {
	if kp.Code != code {
		t.Errorf("code mismatch after decoding: %d != %d", code, kp.Code)
	}
	if kp.Name != name {
		t.Errorf("name mismatch after decoding: %s != %s", name, kp.Name)
	}
	if bytes.Compare(private, kp.Private) != 0 {
		t.Errorf(
			"private key mismatch after decoding: %s != %s",
			private,
			kp.Private,
		)
	}
	if len(private) != len(kp.Private) {
		t.Errorf(
			"private key length mismatch: %d != %d",
			len(private),
			len(kp.Private),
		)
	}
	if len(kp.Private) != kp.PrivateLength {
		t.Errorf(
			"private key length not accurate: %d != %d",
			len(kp.Private),
			kp.PrivateLength,
		)
	}
	if bytes.Compare(public, kp.Public) != 0 {
		t.Errorf(
			"public key mismatch after decoding: %s != %s",
			public,
			kp.Public,
		)
	}
	if len(public) != len(kp.Public) {
		t.Errorf(
			"public key mismatch after decoding: %d != %d",
			len(public),
			len(kp.Public),
		)
	}
}
